// Type: Protocol layer definitions

syntax = "proto3";
package dvote.types.v1;

option go_package = "go.vocdoni.io/proto/build/go/models";

///////////////////////////////////////////////////////////////////////////////
// Census models
///////////////////////////////////////////////////////////////////////////////

// The models below affect the whole election definition.
message Census {

	message Arbo {
		bytes censusRoot = 1;
		string censusUri = 2;
	}
	message Csp {
		enum Type {
			UNKNOWN = 0;
			ECDSA = 1;
			ECDSA_PIDSALTED = 2;
			ECDSA_BLIND = 3;
			ECDSA_BLIND_PIDSALTED = 4;
		}
		// The kind of signature expected as a proof
		Type type = 1;

		string cspUri = 2;
		bytes cspPublicKey = 3;
	}

	message EthereumStorage {
		bytes contractAddress = 1;
		int32 balanceMapSlot = 2;
		// Ethereum block at which the state root is taken
		int32 sourceEthereumBlock = 3;

		// Proof that you are a token holder that can create proposals
		optional Proof.EthereumStorage storageProof = 11;
	}

	oneof body {
		// Off-chain Merkle Tree
		Arbo arbo = 11;
		// Credential service based
		Csp csp = 21;
		// Ethereum storage proofs based
		EthereumStorage ethereumStorage = 31;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Census Proof Models
///////////////////////////////////////////////////////////////////////////////

message Proof {
	// Used to vote on non-anonymous elections, or to register an anonymous key to the Vochain

	message None {}

	// Off-chain censuses /////////////////////////////////////////////////////////

	message Arbo {
		enum Type {
				BLAKE2B = 0;
				POSEIDON = 1;
		}
		Type type = 1;
		bytes siblings = 2;
		bytes value = 3;
	}
	message ArboDelegated {
		// TODO
		// int32 endDelegationBlock = 1;
	}

	// CSP proofs /////////////////////////////////////////////////////////////////

	message CSP {
		// TODO: Move the type to the Census definition, and not the proof itself
		enum Type {
			UNKNOWN = 0;
			ECDSA = 1;
			ECDSA_PIDSALTED = 2;
			ECDSA_BLIND = 3;
			ECDSA_BLIND_PIDSALTED = 4;
		}
		Type type = 1;

		// TODO: Generalize the bundle to allow for signed delegations
		message Bundle {
			bytes processId = 1;
			bytes address = 2;
			// bytes value = 3;
		}
		Bundle bundle = 2;
		bytes signature = 3;
	}

	// Ethereum based proofs //////////////////////////////////////////////////////

	message EthereumStorage {
		message Erc20 {
			// Key that identifies the value stored on-chain
			bytes key = 1;
			// The value stored on-chain (balance)
			bytes value = 2;
			// The RLP encoded siblings
			repeated bytes siblings = 3;
		}
		message Erc721 {}
		message Erc1155 {}
		message Erc777 {}
		message ErcMiniMe {
			// TODO: check
			Erc20 proofPrevBlock = 1;
			Erc20 proofNextBlock = 2;
		}

		oneof body {
			Erc20 erc20 = 1;
			Erc721 erc721 = 2;
			Erc1155 erc1155 = 3;
			Erc777 erc777 = 4;
			ErcMiniMe ercMiniMe = 10;
		}
	}
	message EthereumStorageDelegated {
		// TODO
		// int32 endDelegationBlock = 1;
	}

	// Anonymous proofs /////////////////////////////////////////////////////////

	// Used in elections where the voter anonimity is set to either `ZK_SNARKS` or `ZK_SNARKS_PREREGISTER`
	// Groth16 zkSNARK proof + public inputs
	message ZkSnark {
		// circuitParametersIndex defines the index of the parameter set of the
		// circuit. Each process has defined a set of available parameters for
		// the same circuit, the 'parametersIndex' defines the index of the set
		// for which the ProofZkSNARK belongs for the circuit used in that
		// process.
		int32 circuitParametersIndex = 1;
		
		// a represents a G1 point in Affine coordinates
		repeated string a = 2;
		
		// b represents a G2 point in Affine coordinates, represented by an
		// array of arrays: []string => [2][2]bigint).
		// [w, x, y, z] => [[w, x], [y, z]]
		repeated string b = 3;
		
		// c represents a G1 point in Affine coordinates
		repeated string c = 4;
		repeated string publicInputs = 5;
	}


	oneof body {
    // SIGNED PROOFS
		None none = 1;

		// Off-chain Merkle Tree
		Arbo arbo = 11;
		
		// Credential service based
		CSP csp = 21;

		// Ethereum storage proofs based
		EthereumStorage ethereumStorage = 31;

    // ANONYMOUS PROOFS
		ZkSnark zkSnark = 101;
	}
}


///////////////////////////////////////////////////////////////////////////////
// Non-Census Proof Models
///////////////////////////////////////////////////////////////////////////////

message ProofEthereumAccount {
	bytes nonce = 1;
	bytes balance = 2;  // Big Int encoded as bytes
	bytes storageHash = 3;
	bytes codeHash = 4;
	repeated bytes siblings = 5;
}
